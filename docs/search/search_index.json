{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acai \u00b6 DRY, configurable, declarative node library for working with Amazon Web Service Lambdas. Features \u00b6 Highly configurable apigateway internal router Openapi schema adherence for all event types Extensible and customizable middleware for validation and other tasks DRY coding interfaces without the need of boilerplate Ease-of-use with the serverless framework Local Development support Happy Path Programming (See Philosophy below) Philosophy \u00b6 The Acai philosophy is to provide a dry, configurable, declarative library for use with the amazon lambdas, which encourages Happy Path Programming (HPP). Happy Path Programming is an idea in which inputs are all validated before operated on. This ensures code follows the happy path without the need for mid-level, nested exceptions and all the nasty exception handling that comes with that. The library uses layers of customizable middleware options to allow a developer to easily dictate what constitutes a valid input, without nested conditionals, try/catch blocks or other coding blocks which distract from the happy path that covers the majority of that codes intended operation.","title":"Home"},{"location":"#acai","text":"DRY, configurable, declarative node library for working with Amazon Web Service Lambdas.","title":"Acai"},{"location":"#features","text":"Highly configurable apigateway internal router Openapi schema adherence for all event types Extensible and customizable middleware for validation and other tasks DRY coding interfaces without the need of boilerplate Ease-of-use with the serverless framework Local Development support Happy Path Programming (See Philosophy below)","title":"Features"},{"location":"#philosophy","text":"The Acai philosophy is to provide a dry, configurable, declarative library for use with the amazon lambdas, which encourages Happy Path Programming (HPP). Happy Path Programming is an idea in which inputs are all validated before operated on. This ensures code follows the happy path without the need for mid-level, nested exceptions and all the nasty exception handling that comes with that. The library uses layers of customizable middleware options to allow a developer to easily dictate what constitutes a valid input, without nested conditionals, try/catch blocks or other coding blocks which distract from the happy path that covers the majority of that codes intended operation.","title":"Philosophy"},{"location":"changes/","text":"Changes to the Acai from 1.x to 2.0 \u00b6 In version 2.0 we have added a lot of cool new features, but that does require deprecating some old things. Below is a list of all the changes: Tip If you don't want to make the changes yourself manually, we have a script which will make the changes for you. Just run this command in your terminal from the root of the directory of the project you want to upgrade: 1 /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/syngenta/acai-js-docs/main/scripts/node-upgrade.sh ) \" APIGateway \u00b6 old new description router.route() router.route(event) router.route now requires the event to be passed in requiredParams requiredQuery requiredQuery is how you define required query string params request.params request.query request.query is how you access query string params DynamoDB, S3 & SNS/SQS Event \u00b6 old new description event.records await event.getRecords() to use advance validation features, you must the async method; .records still works DynamoDB Record \u00b6 old new record.approximateCreationDateTime record.created record.awsRegion record.region record.eventID record.id record.eventName record.name record.eventSource record.source record.eventSourceARN record.sourceARN record.streamViewType record.streamType record.sizeBytes record.size record.userIdentity record.identity record.timeToLiveExpired record.expired S3 Record \u00b6 old new record.awsRegion record.region record.eventID record.id record.eventName record.name record.eventSource record.source record.eventSourceARN record.sourceARN record.requestParameters record.request record.responseElements record.response record.s3SchemaVersion record.version SNS/SQS Record \u00b6 old new record.awsRegion record.region record.eventName record.name record.eventSource record.source record.eventSourceARN record.sourceARN record.messageId record.id record.rawBody record.raw","title":"2.0 Breaking Changes"},{"location":"changes/#changes-to-the-acai-from-1x-to-20","text":"In version 2.0 we have added a lot of cool new features, but that does require deprecating some old things. Below is a list of all the changes: Tip If you don't want to make the changes yourself manually, we have a script which will make the changes for you. Just run this command in your terminal from the root of the directory of the project you want to upgrade: 1 /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/syngenta/acai-js-docs/main/scripts/node-upgrade.sh ) \"","title":"Changes to the Acai from 1.x to 2.0"},{"location":"changes/#apigateway","text":"old new description router.route() router.route(event) router.route now requires the event to be passed in requiredParams requiredQuery requiredQuery is how you define required query string params request.params request.query request.query is how you access query string params","title":"APIGateway"},{"location":"changes/#dynamodb-s3-snssqs-event","text":"old new description event.records await event.getRecords() to use advance validation features, you must the async method; .records still works","title":"DynamoDB, S3 &amp; SNS/SQS Event"},{"location":"changes/#dynamodb-record","text":"old new record.approximateCreationDateTime record.created record.awsRegion record.region record.eventID record.id record.eventName record.name record.eventSource record.source record.eventSourceARN record.sourceARN record.streamViewType record.streamType record.sizeBytes record.size record.userIdentity record.identity record.timeToLiveExpired record.expired","title":"DynamoDB Record"},{"location":"changes/#s3-record","text":"old new record.awsRegion record.region record.eventID record.id record.eventName record.name record.eventSource record.source record.eventSourceARN record.sourceARN record.requestParameters record.request record.responseElements record.response record.s3SchemaVersion record.version","title":"S3 Record"},{"location":"changes/#snssqs-record","text":"old new record.awsRegion record.region record.eventName record.name record.eventSource record.source record.eventSourceARN record.sourceARN record.messageId record.id record.rawBody record.raw","title":"SNS/SQS Record"},{"location":"demo/","text":"Demo & Explanation of the Acai \u00b6 Video (~30min) \u00b6 Chapters \u00b6 00:00 Intro 00:20 What is the Acai 04:30 Acai with DynamoDB Streams Demo 09:38 Acai with S3 Events Demo 11:54 Acai with SNS/SQS Events Demo 12:39 Acai with ApiGateway Explanation 16:00 Acai with ApiGateway Demo 31:10 Breaking Changes 31:40 Outro","title":"Demo"},{"location":"demo/#demo-explanation-of-the-acai","text":"","title":"Demo &amp; Explanation of the Acai"},{"location":"demo/#video-30min","text":"","title":"Video (~30min)"},{"location":"demo/#chapters","text":"00:00 Intro 00:20 What is the Acai 04:30 Acai with DynamoDB Streams Demo 09:38 Acai with S3 Events Demo 11:54 Acai with SNS/SQS Events Demo 12:39 Acai with ApiGateway Explanation 16:00 Acai with ApiGateway Demo 31:10 Breaking Changes 31:40 Outro","title":"Chapters"},{"location":"install/","text":"Requirements \u00b6 Node 10.10 or higher; download and install Node.js Access to public npm registry Installation \u00b6 Shell 1 $ npm install acai-js","title":"Install"},{"location":"install/#requirements","text":"Node 10.10 or higher; download and install Node.js Access to public npm registry","title":"Requirements"},{"location":"install/#installation","text":"Shell 1 $ npm install acai-js","title":"Installation"},{"location":"apigateway/","text":"Event handler for Amazon APIGateway REST & GraphQL. Features \u00b6 Configurable router based on 3 common routing patterns Built-in request validation using standard OpenAPI schema Easily validate request in modular and declarative way without any additional code Able to easily extend with custom middleware at both app and per-endpoint levels Support for CORS, binary and Gzip compression","title":"APIGateway"},{"location":"apigateway/#features","text":"Configurable router based on 3 common routing patterns Built-in request validation using standard OpenAPI schema Easily validate request in modular and declarative way without any additional code Able to easily extend with custom middleware at both app and per-endpoint levels Support for CORS, binary and Gzip compression","title":"Features"},{"location":"apigateway/request/","text":"Request Object \u00b6 By default, every endpoint function will receive an instance of the RequestClient class (aka request ) as the first argument of their function. This request has a lot of properties which will do common things automatically, but still allows the developer to override those operations if they deem necessary. Below is a list and examples of all the properties of the request : Example Don't like reading documentation? Then look at our examples which can run locally! Request Properties \u00b6 property type mutable description method str no the http method of the request resource str no the AWS resource being invoked authorizer object no if using a customized authorizer, the authorizer object headers object no the headers of the request params object no combination of query string and path params in one object queryParams object no query string parameters from the request pathParams object no the path parameters of the request route str no the requested route with placeholders of params path str no the raw requested path with actual param values json object no the body of the request, converted from json string in object xml object no the body of the request, converted from xml string in object graphql str no the body of the graphql request as a string body any no the body of the request, converted to based on data type raw any no the raw body of the request no conversion context object yes mutable request context to assigned and pass around event object no the full event originally coming from the lambda request.method \u00b6 1 2 3 4 console . log ( request . method ); // example output: 'get' request.resource \u00b6 1 2 3 4 console . log ( request . resource ); // example output: '/{proxy+}' request.authorizer \u00b6 Tip This is only useful if you are using an external authorizer with your lambda. 1 2 3 4 5 6 7 8 9 10 console . log ( request . authorizer ); // example output: { apiKey : 'SOME KEY' , userId : 'x-1-3-4' , correlationId : 'abc12312' , principalId : '9de3f415a97e410386dbef146e88744e' , integrationLatency : 572 } request.headers \u00b6 1 2 3 4 5 6 7 console . log ( request . headers ); // example output: { 'x-api-key' : 'SOME-KEY' , 'content-type' : 'application/json' } request.params \u00b6 Info This combines both path parameters and query string parameters, nested in one object. 1 2 3 4 5 6 7 8 9 10 11 console . log ( request . params ); // example output: { query : { name : 'me' }, path : { id : 1 } } request.queryParams \u00b6 1 2 3 4 5 6 console . log ( request . queryParams ); // example output: { name : 'me' } request.pathParams \u00b6 1 2 3 4 5 6 console . log ( request . pathParams ); // example output: { id : 1 } request.route \u00b6 Info This will provide the route with the path param variables included 1 2 3 4 console . log ( request . route ); // example output: 'grower/{id}' request.path \u00b6 Info This will provide the route with the path param values replacing the variables 1 2 3 4 console . log ( request . path ); // example output: 'grower/1' request.json \u00b6 Warning This will raise an unhandled exception if the body is not json compatible 1 2 3 4 5 6 console . log ( request . json ); // example output: { someJsonKey : 'someJsonValue' } request.xml \u00b6 Warning This will raise an unhandled exception if the body is not xml compatible 1 2 3 4 5 6 console . log ( request . xml ); // example output: { someXMLKey : 'someXMLValue' } request.graphql \u00b6 Info This is graphql string since there is no object equivalent; you can pass this directly to your graphql resolver 1 2 3 4 5 6 7 8 console . log ( request . graphql ); // example output: '{ players { name } }' request.body \u00b6 Tip This is the safest way to get the body of the request. It will use the content-type header to determine the data sent and convert it; if the data can't be converted for whatever reason it will catch the error and return the raw body provided unconverted. 1 2 3 4 5 6 console . log ( request . body ); // example output: { someXMLKey : 'someXMLValue' } request.raw \u00b6 1 2 3 console . log ( request . raw ); // example output: whatever the raw data of the body is; string, json string, xml, binary, etc request.context \u00b6 Tip This is the only mutable property of the request, to be used by any of the before or beforeAll middleware options 1 2 3 4 5 6 7 request . context = { application_assignable : true } console . log ( request . context ); // example output: { application_assignable : true } request.event \u00b6 Warning This is the original full request. Not advisable to use this as defeats the purpose of the entire Acai . In addition, you don't want to mutate this object and potentially mess up the entire router. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 console . log ( request . event ); // example output: { \"version\" : \"2.0\" , \"routeKey\" : \"$default\" , \"rawPath\" : \"/my/path\" , \"rawQueryString\" : \"parameter1=value1&parameter1=value2&parameter2=value\" , \"cookies\" : [ \"cookie1\" , \"cookie2\" ], \"headers\" : { \"header1\" : \"value1\" , \"header2\" : \"value1,value2\" }, \"queryStringParameters\" : { \"parameter1\" : \"value1,value2\" , \"parameter2\" : \"value\" }, \"requestContext\" : { \"accountId\" : \"123456789012\" , \"apiId\" : \"api-id\" , \"authentication\" : { \"clientCert\" : { \"clientCertPem\" : \"CERT_CONTENT\" , \"subjectDN\" : \"www.example.com\" , \"issuerDN\" : \"Example issuer\" , \"serialNumber\" : \"a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1\" , \"validity\" : { \"notBefore\" : \"May 28 12:30:02 2019 GMT\" , \"notAfter\" : \"Aug 5 09:36:04 2021 GMT\" } } }, \"authorizer\" : { \"jwt\" : { \"claims\" : { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" }, \"scopes\" : [ \"scope1\" , \"scope2\" ] } }, \"domainName\" : \"id.execute-api.us-east-1.amazonaws.com\" , \"domainPrefix\" : \"id\" , \"http\" : { \"method\" : \"POST\" , \"path\" : \"/my/path\" , \"protocol\" : \"HTTP/1.1\" , \"sourceIp\" : \"IP\" , \"userAgent\" : \"agent\" }, \"requestId\" : \"id\" , \"routeKey\" : \"$default\" , \"stage\" : \"$default\" , \"time\" : \"12/Mar/2020:19:03:58 +0000\" , \"timeEpoch\" : 1583348638390 }, \"body\" : \"Hello from Lambda\" , \"pathParameters\" : { \"parameter1\" : \"value1\" }, \"isBase64Encoded\" : false , \"stageVariables\" : { \"stageVariable1\" : \"value1\" , \"stageVariable2\" : \"value2\" } }","title":"Request"},{"location":"apigateway/request/#request-object","text":"By default, every endpoint function will receive an instance of the RequestClient class (aka request ) as the first argument of their function. This request has a lot of properties which will do common things automatically, but still allows the developer to override those operations if they deem necessary. Below is a list and examples of all the properties of the request : Example Don't like reading documentation? Then look at our examples which can run locally!","title":"Request Object"},{"location":"apigateway/request/#request-properties","text":"property type mutable description method str no the http method of the request resource str no the AWS resource being invoked authorizer object no if using a customized authorizer, the authorizer object headers object no the headers of the request params object no combination of query string and path params in one object queryParams object no query string parameters from the request pathParams object no the path parameters of the request route str no the requested route with placeholders of params path str no the raw requested path with actual param values json object no the body of the request, converted from json string in object xml object no the body of the request, converted from xml string in object graphql str no the body of the graphql request as a string body any no the body of the request, converted to based on data type raw any no the raw body of the request no conversion context object yes mutable request context to assigned and pass around event object no the full event originally coming from the lambda","title":"Request Properties"},{"location":"apigateway/request/#requestmethod","text":"1 2 3 4 console . log ( request . method ); // example output: 'get'","title":"request.method"},{"location":"apigateway/request/#requestresource","text":"1 2 3 4 console . log ( request . resource ); // example output: '/{proxy+}'","title":"request.resource"},{"location":"apigateway/request/#requestauthorizer","text":"Tip This is only useful if you are using an external authorizer with your lambda. 1 2 3 4 5 6 7 8 9 10 console . log ( request . authorizer ); // example output: { apiKey : 'SOME KEY' , userId : 'x-1-3-4' , correlationId : 'abc12312' , principalId : '9de3f415a97e410386dbef146e88744e' , integrationLatency : 572 }","title":"request.authorizer"},{"location":"apigateway/request/#requestheaders","text":"1 2 3 4 5 6 7 console . log ( request . headers ); // example output: { 'x-api-key' : 'SOME-KEY' , 'content-type' : 'application/json' }","title":"request.headers"},{"location":"apigateway/request/#requestparams","text":"Info This combines both path parameters and query string parameters, nested in one object. 1 2 3 4 5 6 7 8 9 10 11 console . log ( request . params ); // example output: { query : { name : 'me' }, path : { id : 1 } }","title":"request.params"},{"location":"apigateway/request/#requestqueryparams","text":"1 2 3 4 5 6 console . log ( request . queryParams ); // example output: { name : 'me' }","title":"request.queryParams"},{"location":"apigateway/request/#requestpathparams","text":"1 2 3 4 5 6 console . log ( request . pathParams ); // example output: { id : 1 }","title":"request.pathParams"},{"location":"apigateway/request/#requestroute","text":"Info This will provide the route with the path param variables included 1 2 3 4 console . log ( request . route ); // example output: 'grower/{id}'","title":"request.route"},{"location":"apigateway/request/#requestpath","text":"Info This will provide the route with the path param values replacing the variables 1 2 3 4 console . log ( request . path ); // example output: 'grower/1'","title":"request.path"},{"location":"apigateway/request/#requestjson","text":"Warning This will raise an unhandled exception if the body is not json compatible 1 2 3 4 5 6 console . log ( request . json ); // example output: { someJsonKey : 'someJsonValue' }","title":"request.json"},{"location":"apigateway/request/#requestxml","text":"Warning This will raise an unhandled exception if the body is not xml compatible 1 2 3 4 5 6 console . log ( request . xml ); // example output: { someXMLKey : 'someXMLValue' }","title":"request.xml"},{"location":"apigateway/request/#requestgraphql","text":"Info This is graphql string since there is no object equivalent; you can pass this directly to your graphql resolver 1 2 3 4 5 6 7 8 console . log ( request . graphql ); // example output: '{ players { name } }'","title":"request.graphql"},{"location":"apigateway/request/#requestbody","text":"Tip This is the safest way to get the body of the request. It will use the content-type header to determine the data sent and convert it; if the data can't be converted for whatever reason it will catch the error and return the raw body provided unconverted. 1 2 3 4 5 6 console . log ( request . body ); // example output: { someXMLKey : 'someXMLValue' }","title":"request.body"},{"location":"apigateway/request/#requestraw","text":"1 2 3 console . log ( request . raw ); // example output: whatever the raw data of the body is; string, json string, xml, binary, etc","title":"request.raw"},{"location":"apigateway/request/#requestcontext","text":"Tip This is the only mutable property of the request, to be used by any of the before or beforeAll middleware options 1 2 3 4 5 6 7 request . context = { application_assignable : true } console . log ( request . context ); // example output: { application_assignable : true }","title":"request.context"},{"location":"apigateway/request/#requestevent","text":"Warning This is the original full request. Not advisable to use this as defeats the purpose of the entire Acai . In addition, you don't want to mutate this object and potentially mess up the entire router. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 console . log ( request . event ); // example output: { \"version\" : \"2.0\" , \"routeKey\" : \"$default\" , \"rawPath\" : \"/my/path\" , \"rawQueryString\" : \"parameter1=value1&parameter1=value2&parameter2=value\" , \"cookies\" : [ \"cookie1\" , \"cookie2\" ], \"headers\" : { \"header1\" : \"value1\" , \"header2\" : \"value1,value2\" }, \"queryStringParameters\" : { \"parameter1\" : \"value1,value2\" , \"parameter2\" : \"value\" }, \"requestContext\" : { \"accountId\" : \"123456789012\" , \"apiId\" : \"api-id\" , \"authentication\" : { \"clientCert\" : { \"clientCertPem\" : \"CERT_CONTENT\" , \"subjectDN\" : \"www.example.com\" , \"issuerDN\" : \"Example issuer\" , \"serialNumber\" : \"a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1\" , \"validity\" : { \"notBefore\" : \"May 28 12:30:02 2019 GMT\" , \"notAfter\" : \"Aug 5 09:36:04 2021 GMT\" } } }, \"authorizer\" : { \"jwt\" : { \"claims\" : { \"claim1\" : \"value1\" , \"claim2\" : \"value2\" }, \"scopes\" : [ \"scope1\" , \"scope2\" ] } }, \"domainName\" : \"id.execute-api.us-east-1.amazonaws.com\" , \"domainPrefix\" : \"id\" , \"http\" : { \"method\" : \"POST\" , \"path\" : \"/my/path\" , \"protocol\" : \"HTTP/1.1\" , \"sourceIp\" : \"IP\" , \"userAgent\" : \"agent\" }, \"requestId\" : \"id\" , \"routeKey\" : \"$default\" , \"stage\" : \"$default\" , \"time\" : \"12/Mar/2020:19:03:58 +0000\" , \"timeEpoch\" : 1583348638390 }, \"body\" : \"Hello from Lambda\" , \"pathParameters\" : { \"parameter1\" : \"value1\" }, \"isBase64Encoded\" : false , \"stageVariables\" : { \"stageVariable1\" : \"value1\" , \"stageVariable2\" : \"value2\" } }","title":"request.event"},{"location":"apigateway/response/","text":"Response Object \u00b6 By default, every endpoint function will receive an instance of the ResponseClient class (aka response ) as the second argument of their function. This response object is meant to provide consistency to HTTP response codes and error signatures. Below is a list and examples of all the properties of the response : Example Don't like reading documentation? Then look at our examples which can run locally! Response Properties \u00b6 property type description headers object provide headers in key/value pairs to add new headers code int http response code to be returned the requester body any body of the response automatically converted to JSON string rawBody any body of the response not converted to JSON string compress bool will compress the body if set to true and add proper headers setError func function to set an error with a key and value hasError boolean simple property to check if response already has errors in it response.headers \u00b6 1 2 3 4 5 6 7 8 9 10 response . headers = { key : 'status' , value : 'ok' }; response . headers = { key : 'response_id' , value : 'some-guid' }; console . log ( response . headers ); // example output: { status : 'ok' , response_id : 'some-guid' , } response.code \u00b6 1 2 3 4 5 6 response . code = 418 ; console . log ( response . code ); // example output: 418 response.body \u00b6 Info This will automatically convert the body to json if possible when called. 1 2 3 4 5 6 response . body = { someKey : 'someValue' }; console . log ( response . body ); // example output: '{\"someKey\":\"someValue\"}' response.rawBody \u00b6 Info This will NOT automatically convert the body to json if possible when called. This is great when working with an afterAll method that wants to mutate the body of the response before returning to the user. 1 2 3 4 5 6 7 8 response . rawBody = { someKey : 'someValue' }; console . log ( response . rawBody ); // example output: { someKey : 'someValue' } response.compress \u00b6 Info This will compress whatever is in the body property. 1 2 3 4 response . compress = true ; console . log ( response . body ); // example output: this will gzip and compress the body. response.setError(key, value) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const someKey = 'abc123' ; response . setError ( 'someKey' , ` ${ someKey } is not a valid key to use with this service; try again with a different key` ); const anotherKey = 'def456' ; response . setError ( 'anotherKey' , ` ${ anotherKey } is not the correct type to operate on` ); console . log ( response . rawBody ); // example output: { errors : [ { key_path : 'someKey' , message : 'abc123 is not a valid key to use with this service; try again with a different key' }, { key_path : 'anotherKey' , message : 'def456 is not the correct type to operate on' } ] } response.hasError \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 response . setError ( 'user' , `your access is denied` ); console . log ( response . hasError ); // example output: true response . body = { user : 'you have been granted access' }; console . log ( response . hasError ); // example output: false","title":"Response"},{"location":"apigateway/response/#response-object","text":"By default, every endpoint function will receive an instance of the ResponseClient class (aka response ) as the second argument of their function. This response object is meant to provide consistency to HTTP response codes and error signatures. Below is a list and examples of all the properties of the response : Example Don't like reading documentation? Then look at our examples which can run locally!","title":"Response Object"},{"location":"apigateway/response/#response-properties","text":"property type description headers object provide headers in key/value pairs to add new headers code int http response code to be returned the requester body any body of the response automatically converted to JSON string rawBody any body of the response not converted to JSON string compress bool will compress the body if set to true and add proper headers setError func function to set an error with a key and value hasError boolean simple property to check if response already has errors in it","title":"Response Properties"},{"location":"apigateway/response/#responseheaders","text":"1 2 3 4 5 6 7 8 9 10 response . headers = { key : 'status' , value : 'ok' }; response . headers = { key : 'response_id' , value : 'some-guid' }; console . log ( response . headers ); // example output: { status : 'ok' , response_id : 'some-guid' , }","title":"response.headers"},{"location":"apigateway/response/#responsecode","text":"1 2 3 4 5 6 response . code = 418 ; console . log ( response . code ); // example output: 418","title":"response.code"},{"location":"apigateway/response/#responsebody","text":"Info This will automatically convert the body to json if possible when called. 1 2 3 4 5 6 response . body = { someKey : 'someValue' }; console . log ( response . body ); // example output: '{\"someKey\":\"someValue\"}'","title":"response.body"},{"location":"apigateway/response/#responserawbody","text":"Info This will NOT automatically convert the body to json if possible when called. This is great when working with an afterAll method that wants to mutate the body of the response before returning to the user. 1 2 3 4 5 6 7 8 response . rawBody = { someKey : 'someValue' }; console . log ( response . rawBody ); // example output: { someKey : 'someValue' }","title":"response.rawBody"},{"location":"apigateway/response/#responsecompress","text":"Info This will compress whatever is in the body property. 1 2 3 4 response . compress = true ; console . log ( response . body ); // example output: this will gzip and compress the body.","title":"response.compress"},{"location":"apigateway/response/#responseseterrorkey-value","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const someKey = 'abc123' ; response . setError ( 'someKey' , ` ${ someKey } is not a valid key to use with this service; try again with a different key` ); const anotherKey = 'def456' ; response . setError ( 'anotherKey' , ` ${ anotherKey } is not the correct type to operate on` ); console . log ( response . rawBody ); // example output: { errors : [ { key_path : 'someKey' , message : 'abc123 is not a valid key to use with this service; try again with a different key' }, { key_path : 'anotherKey' , message : 'def456 is not the correct type to operate on' } ] }","title":"response.setError(key, value)"},{"location":"apigateway/response/#responsehaserror","text":"1 2 3 4 5 6 7 8 9 10 11 12 response . setError ( 'user' , `your access is denied` ); console . log ( response . hasError ); // example output: true response . body = { user : 'you have been granted access' }; console . log ( response . hasError ); // example output: false","title":"response.hasError"},{"location":"apigateway/endpoint/configurations/","text":"Endpoint Configurations \u00b6 In order to encourage \"Happy Path Programming\" and make it easier for developers to validate request fully, the Acai comes with a host of built-in validations as well as the ability to extend with custom validations and middleware. See the full validation list here: Examples Don't like reading documentation? Then look at our examples, which can run locally! Validation Configurations \u00b6 requirement type description requiredHeaders array every header in this array must be in the headers of request availableHeaders array only headers in this array will be allowed in the request requiredQuery array every item in the array is a required query string parameter availableQuery array only items in this array are allowed in the request requiredPath str when using parameters, this is the required parameters requiredBody str references a JSschema component in your schemaFile requiredAuth bool will trigger withAuth function defined in the router config before func a custom function to be ran before your method function after func a custom function to be ran after your method function dataClass class a custom class that will be passed instead of the request obj [ custom-requirement ] any see bottom of page requiredHeaders \u00b6 Info Headers are case-sensitive, make sure your casing matches your expectations. 1 2 3 4 5 exports . requirements = { post : { requiredHeaders : [ 'x-onbehalf-of' ] } }; availableHeaders \u00b6 Warning This is not recommended for frequent use as it raises errors for every header which does not conform to the array provided. Many browsers, http tools, and libraries will automatically add headers to request, unbeknownst to the user. By using this setting, you will force every user of the endpoint to take extra care with the headers provided and may result in poor API consumer experience. 1 2 3 4 5 exports . requirements = { post : { availableHeaders : [ 'x-onbehalf-of' ] } }; requiredQuery \u00b6 1 2 3 4 5 exports . requirements = { get : { requiredQuery : [ 'requester_id' ] } }; availableQuery \u00b6 1 2 3 4 5 exports . requirements = { get : { availableQuery : [ 'grower_email' , 'grower_phone' , 'grower_first' , 'grower_last' ], } }; requiredPath \u00b6 Warning This is required if you are using dynamic routing (ex. {id}.js ) with path parameters. The router will provide a path values in request.pathParams 1 2 3 4 5 exports . requirements = { put : { requiredPath : 'grower/{id}' } }; requiredBody \u00b6 Info This is referencing a components.schemas section of your openapi.yml file defined in the schemaFile value in your router config. 1 2 3 4 5 exports . requirements = { post : { requiredBody : 'post-grower-request' } }; requiredAuth \u00b6 Info This will trigger the function you provided in the router config under the withAuth configuration 1 2 3 4 5 exports . requirements = { post : { requiredAuth : true } }; before \u00b6 1 2 3 4 5 6 7 8 9 10 exports . requirements = { patch : { before : async ( request , response , requirements ) => { const result = await db . checkGrowerIdExists ( request . pathParams . id ); if ( ! result ){ response . setError ( 'grower/{id}' , `grower with id: ${ id } does not exist.` ); } } } }; after \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 exports . requirements = { get : { after : async ( request , response , requirements ) => { const relations = await db . getRequesterRelations ( request . headers [ 'x-requester-id' ]); const results = [] for ( const grower in response . rawBody ){ if ( relations . includes ( grower . id )){ results . push ( grower ); } } response . body = results ; return response ; } } }; dataClass \u00b6 Info Instead of getting a request and response as arguments passed to your API function, you will get an instance of the class you provided here 1 2 3 4 5 exports . requirements = { post : { dataClass : Grower } }; custom requirements (example) \u00b6 Info You can add as many custom requirements as you want, with any variable type you want, and they will be passed to your beforeAll , before , afterAll , after and withAuth middleware defined functions. 1 2 3 4 5 exports . requirements = { post : { myCustomBeforeAllPermission : { permission : 'allow-delete-grower' } } };","title":"Configurations"},{"location":"apigateway/endpoint/configurations/#endpoint-configurations","text":"In order to encourage \"Happy Path Programming\" and make it easier for developers to validate request fully, the Acai comes with a host of built-in validations as well as the ability to extend with custom validations and middleware. See the full validation list here: Examples Don't like reading documentation? Then look at our examples, which can run locally!","title":"Endpoint Configurations"},{"location":"apigateway/endpoint/configurations/#validation-configurations","text":"requirement type description requiredHeaders array every header in this array must be in the headers of request availableHeaders array only headers in this array will be allowed in the request requiredQuery array every item in the array is a required query string parameter availableQuery array only items in this array are allowed in the request requiredPath str when using parameters, this is the required parameters requiredBody str references a JSschema component in your schemaFile requiredAuth bool will trigger withAuth function defined in the router config before func a custom function to be ran before your method function after func a custom function to be ran after your method function dataClass class a custom class that will be passed instead of the request obj [ custom-requirement ] any see bottom of page","title":"Validation Configurations"},{"location":"apigateway/endpoint/configurations/#requiredheaders","text":"Info Headers are case-sensitive, make sure your casing matches your expectations. 1 2 3 4 5 exports . requirements = { post : { requiredHeaders : [ 'x-onbehalf-of' ] } };","title":"requiredHeaders"},{"location":"apigateway/endpoint/configurations/#availableheaders","text":"Warning This is not recommended for frequent use as it raises errors for every header which does not conform to the array provided. Many browsers, http tools, and libraries will automatically add headers to request, unbeknownst to the user. By using this setting, you will force every user of the endpoint to take extra care with the headers provided and may result in poor API consumer experience. 1 2 3 4 5 exports . requirements = { post : { availableHeaders : [ 'x-onbehalf-of' ] } };","title":"availableHeaders"},{"location":"apigateway/endpoint/configurations/#requiredquery","text":"1 2 3 4 5 exports . requirements = { get : { requiredQuery : [ 'requester_id' ] } };","title":"requiredQuery"},{"location":"apigateway/endpoint/configurations/#availablequery","text":"1 2 3 4 5 exports . requirements = { get : { availableQuery : [ 'grower_email' , 'grower_phone' , 'grower_first' , 'grower_last' ], } };","title":"availableQuery"},{"location":"apigateway/endpoint/configurations/#requiredpath","text":"Warning This is required if you are using dynamic routing (ex. {id}.js ) with path parameters. The router will provide a path values in request.pathParams 1 2 3 4 5 exports . requirements = { put : { requiredPath : 'grower/{id}' } };","title":"requiredPath"},{"location":"apigateway/endpoint/configurations/#requiredbody","text":"Info This is referencing a components.schemas section of your openapi.yml file defined in the schemaFile value in your router config. 1 2 3 4 5 exports . requirements = { post : { requiredBody : 'post-grower-request' } };","title":"requiredBody"},{"location":"apigateway/endpoint/configurations/#requiredauth","text":"Info This will trigger the function you provided in the router config under the withAuth configuration 1 2 3 4 5 exports . requirements = { post : { requiredAuth : true } };","title":"requiredAuth"},{"location":"apigateway/endpoint/configurations/#before","text":"1 2 3 4 5 6 7 8 9 10 exports . requirements = { patch : { before : async ( request , response , requirements ) => { const result = await db . checkGrowerIdExists ( request . pathParams . id ); if ( ! result ){ response . setError ( 'grower/{id}' , `grower with id: ${ id } does not exist.` ); } } } };","title":"before"},{"location":"apigateway/endpoint/configurations/#after","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 exports . requirements = { get : { after : async ( request , response , requirements ) => { const relations = await db . getRequesterRelations ( request . headers [ 'x-requester-id' ]); const results = [] for ( const grower in response . rawBody ){ if ( relations . includes ( grower . id )){ results . push ( grower ); } } response . body = results ; return response ; } } };","title":"after"},{"location":"apigateway/endpoint/configurations/#dataclass","text":"Info Instead of getting a request and response as arguments passed to your API function, you will get an instance of the class you provided here 1 2 3 4 5 exports . requirements = { post : { dataClass : Grower } };","title":"dataClass"},{"location":"apigateway/endpoint/configurations/#custom-requirements-example","text":"Info You can add as many custom requirements as you want, with any variable type you want, and they will be passed to your beforeAll , before , afterAll , after and withAuth middleware defined functions. 1 2 3 4 5 exports . requirements = { post : { myCustomBeforeAllPermission : { permission : 'allow-delete-grower' } } };","title":"custom requirements (example)"},{"location":"apigateway/endpoint/setup/","text":"Endpoint Set Up \u00b6 Each endpoint is meant to be treated as a separate module within the API. These endpoints are not meant to be extended or commingled and thus should approach individually. If resources are meant to be shared across endpoints, then those resources should be packaged as shared classes or utilities. Each endpoint should read as a procedural list of steps to be completed. To help keep this list clean and easy to read, the Acai follows its philosophy of \"Happy Path Programming.\" To achieve this, the Acai comes with a plethora of validation configurations with the ability to extend with even more customized validation options. This ensures the request sent to your endpoint will be correct with little need for exception handling or complex conditionals. Examples Don't like reading documentation? Then look at our examples, which can run locally! 1. Match Function to HTTP Method \u00b6 Each endpoint must have stateless functions which match the name of the HTTP method. If endpoint is called the a POST HTTP method, then the post endpoint function is invoked. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // example for endpoint file: api/grower.js exports . requirements = {}; // discussed in next section below exports . post = async ( request , response ) => { response . body = { message : '[POST] /grower was called' }; return response ; }; exports . get = async ( request , response ) => { response . body = { message : '[GET] /grower was called' }; return response ; }; exports . patch = async ( request , response ) => { response . body = { message : '[PATCH] /grower was called' }; return response ; }; exports . put = async ( request , response ) => { response . body = { message : '[PUT] /grower was called' }; return response ; }; exports . delete = async ( request , response ) => { response . body = { message : '[DELETE] /grower was called' }; return response ; }; exports . query = async ( request , response ) => { response . body = { message : '[QUERY] /grower, a custom http method, was called' }; return response ; }; 2. Configure the Requirements (optional) \u00b6 Each method within the endpoint file can have individual validation requirements. These requirements allow you to test all structural points of the request, with the ability to use JSONSchema and custom middleware to further extend the validation options. Below is an example of a full requirements object: Info See the full configuration list, explanation and example of each setting in our Configurations Section . Tip If you are already using an openapi.yml , none of these requirements below are necessary. Ensure your router has enabled autoValidate with proper schemaPath configured and the below requirements are not necessary for any basic structural validation (headers, body, query, params will be checked via openapi.yml). You can still use before , after & dataClass with other custom validations for more advanced use cases. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // example for endpoint file: api/grower.js const Grower = require ( 'api/logic/grower' ); exports . requirements = { post : { requiredHeaders : [ 'x-onbehalf-of' ], availableHeaders : [ 'x-requester-id' , 'x-test-id' ], //not advisable to use; too strict requiredBody : 'post-grower-request' }, get : { requiredQuery : [ 'requester_id' ], availableQuery : [ 'grower_email' , 'grower_phone' , 'grower_first' , 'grower_last' ], }, put : { requiredPath : 'grower/{id}' , requiredAuth : true , requiredBody : 'put-grower-request' , dataClass : Grower }, patch : { requiredPath : 'grower/{id}' , requiredAuth : true , requiredBody : 'patch-grower-request' , before : async ( request , response , requirements ) => { // might be cleaner to put this in a separate file and call in context. const result = await db . checkGrowerIdExists ( request . pathParams . id ); if ( ! result ){ response . setError ( 'grower/{id}' , `grower with id: ${ id } does not exist.` ); } } }, delete : { requiredPath : 'grower/{id}' , after : async ( request , response , requirements ) => { // might be cleaner to put this in a separate file and call in context. const relations = await db . getRequesterRelations ( request . headers [ 'x-requester-id' ]); const results = [] for ( const grower in response . rawBody ){ if ( relations . includes ( grower . id )){ results . push ( grower ); } } response . body = results ; return response ; } } }; exports . post = async ( request , response ) => { response . body = { message : '[POST] /grower was called' }; return response ; }; exports . get = async ( request , response ) => { response . body = { message : '[GET] /grower was called' }; return response ; }; exports . patch = async ( request , response ) => { response . body = { message : '[PATCH] /grower was called' }; return response ; }; exports . put = async ( grower , response ) => { response . body = { message : '[PUT] /grower was called; got instance of grower instead of request' }; return response ; }; exports . delete = async ( request , response ) => { response . body = { message : '[DELETE] /grower was called' }; return response ; }; exports . query = async ( request , response ) => { response . body = { message : '[QUERY] /grower, a custom http method, was called' }; return response ; };","title":"Set Up"},{"location":"apigateway/endpoint/setup/#endpoint-set-up","text":"Each endpoint is meant to be treated as a separate module within the API. These endpoints are not meant to be extended or commingled and thus should approach individually. If resources are meant to be shared across endpoints, then those resources should be packaged as shared classes or utilities. Each endpoint should read as a procedural list of steps to be completed. To help keep this list clean and easy to read, the Acai follows its philosophy of \"Happy Path Programming.\" To achieve this, the Acai comes with a plethora of validation configurations with the ability to extend with even more customized validation options. This ensures the request sent to your endpoint will be correct with little need for exception handling or complex conditionals. Examples Don't like reading documentation? Then look at our examples, which can run locally!","title":"Endpoint Set Up"},{"location":"apigateway/endpoint/setup/#1-match-function-to-http-method","text":"Each endpoint must have stateless functions which match the name of the HTTP method. If endpoint is called the a POST HTTP method, then the post endpoint function is invoked. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // example for endpoint file: api/grower.js exports . requirements = {}; // discussed in next section below exports . post = async ( request , response ) => { response . body = { message : '[POST] /grower was called' }; return response ; }; exports . get = async ( request , response ) => { response . body = { message : '[GET] /grower was called' }; return response ; }; exports . patch = async ( request , response ) => { response . body = { message : '[PATCH] /grower was called' }; return response ; }; exports . put = async ( request , response ) => { response . body = { message : '[PUT] /grower was called' }; return response ; }; exports . delete = async ( request , response ) => { response . body = { message : '[DELETE] /grower was called' }; return response ; }; exports . query = async ( request , response ) => { response . body = { message : '[QUERY] /grower, a custom http method, was called' }; return response ; };","title":"1. Match Function to HTTP Method"},{"location":"apigateway/endpoint/setup/#2-configure-the-requirements-optional","text":"Each method within the endpoint file can have individual validation requirements. These requirements allow you to test all structural points of the request, with the ability to use JSONSchema and custom middleware to further extend the validation options. Below is an example of a full requirements object: Info See the full configuration list, explanation and example of each setting in our Configurations Section . Tip If you are already using an openapi.yml , none of these requirements below are necessary. Ensure your router has enabled autoValidate with proper schemaPath configured and the below requirements are not necessary for any basic structural validation (headers, body, query, params will be checked via openapi.yml). You can still use before , after & dataClass with other custom validations for more advanced use cases. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // example for endpoint file: api/grower.js const Grower = require ( 'api/logic/grower' ); exports . requirements = { post : { requiredHeaders : [ 'x-onbehalf-of' ], availableHeaders : [ 'x-requester-id' , 'x-test-id' ], //not advisable to use; too strict requiredBody : 'post-grower-request' }, get : { requiredQuery : [ 'requester_id' ], availableQuery : [ 'grower_email' , 'grower_phone' , 'grower_first' , 'grower_last' ], }, put : { requiredPath : 'grower/{id}' , requiredAuth : true , requiredBody : 'put-grower-request' , dataClass : Grower }, patch : { requiredPath : 'grower/{id}' , requiredAuth : true , requiredBody : 'patch-grower-request' , before : async ( request , response , requirements ) => { // might be cleaner to put this in a separate file and call in context. const result = await db . checkGrowerIdExists ( request . pathParams . id ); if ( ! result ){ response . setError ( 'grower/{id}' , `grower with id: ${ id } does not exist.` ); } } }, delete : { requiredPath : 'grower/{id}' , after : async ( request , response , requirements ) => { // might be cleaner to put this in a separate file and call in context. const relations = await db . getRequesterRelations ( request . headers [ 'x-requester-id' ]); const results = [] for ( const grower in response . rawBody ){ if ( relations . includes ( grower . id )){ results . push ( grower ); } } response . body = results ; return response ; } } }; exports . post = async ( request , response ) => { response . body = { message : '[POST] /grower was called' }; return response ; }; exports . get = async ( request , response ) => { response . body = { message : '[GET] /grower was called' }; return response ; }; exports . patch = async ( request , response ) => { response . body = { message : '[PATCH] /grower was called' }; return response ; }; exports . put = async ( grower , response ) => { response . body = { message : '[PUT] /grower was called; got instance of grower instead of request' }; return response ; }; exports . delete = async ( request , response ) => { response . body = { message : '[DELETE] /grower was called' }; return response ; }; exports . query = async ( request , response ) => { response . body = { message : '[QUERY] /grower, a custom http method, was called' }; return response ; };","title":"2. Configure the Requirements (optional)"},{"location":"apigateway/router/configurations/","text":"Router Configurations \u00b6 As mentioned previously, the router is highly configurable to each project needs and desires. The point of the router is to enforce predictable thus making the API more extensible. Below is a table of all the configuration options available: Example Don't like reading documentation? Then look at our examples which can run locally! Configuration Options \u00b6 option type required description afterAll func no will call this function after EVERY request to the API autoValidate bool no; requires schemaPath will automatically validate request against openapi.yml basePath str yes the base path of the API Gateway instance this is running on beforeAll func no will call this function before EVERY request to the API globalLogger bool no will assign the Acai logger to the global variable globalLogger handlerPath str yes, if routingMode == 'directory' file path pointing to the directory where the endpoints are handlerPattern str yes, if routingMode == 'pattern' glob pattern to be able to find the endpoint files handlerList object yes, if routingMode == 'list' object key, value pair to be able to map routes to files loggerCallback func no will call this function on every call to global.logger onError func no will call this function on every unhandled error; not including validation errors routingMode enum yes; directory or pattern or list determines how to route requests to the right files; 3 modes schemaPath str yes, if autoValidate file path pointing to the location of the openapi.yml file withAuth func no will call this function when requirements have requiredAuth set to true Example: Router Config with Directory Routing \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; const MiddlewareUtils = require ( 'api/logic/utils/middleware' ); const Authenticator = require ( 'api/logic/authenticator' ); exports . route = async ( event ) => { const router = new Router ({ basePath : 'api' , routingMode : 'directory' , handlerPath : 'api/handler' , schemaPath : 'api/openapi.yml' , autoValidate : true , globalLogger : true , beforeAll : MiddlewareUtils . beforeAll , afterAll : MiddlewareUtils . afterAll , onError : MiddlewareUtils . onError , withAuth : Authenticator . authenticate , loggerCallback : MiddlewareUtils . loggerCallback , }); return router . route ( event ); }; Example: Router Config with Pattern Routing \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; const MiddlewareUtils = require ( 'api/logic/utils/middleware' ); const Authenticator = require ( 'api/logic/authenticator' ); exports . route = async ( event ) => { const router = new Router ({ basePath : 'api' , routingMode : 'pattern' , handlerPattern : 'api/**/*.controller.js' , schemaPath : 'api/openapi.yml' , autoValidate : true , globalLogger : true , beforeAll : MiddlewareUtils . beforeAll , afterAll : MiddlewareUtils . afterAll , onError : MiddlewareUtils . onError , withAuth : Authenticator . authenticate , loggerCallback : MiddlewareUtils . loggerCallback , }); return router . route ( event ); }; Example: Router Config with List Routing \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; const MiddlewareUtils = require ( 'api/logic/utils/middleware' ); const Authenticator = require ( 'api/logic/authenticator' ); const routes = { 'GET::grower' : 'api/routes/grower.js' , 'POST::farm' : 'api/routes/farm.js' , 'PUT:farm/{farmId}/field/{fieldId}' : 'api/routes/farm-field.js' } exports . route = async ( event ) => { const router = new Router ({ basePath : 'api' , routingMode : 'list' , handlerList : routes , schemaPath : 'api/openapi.yml' , autoValidate : true , globalLogger : true , beforeAll : MiddlewareUtils . beforeAll , afterAll : MiddlewareUtils . afterAll , onError : MiddlewareUtils . onError , withAuth : Authenticator . authenticate , loggerCallback : MiddlewareUtils . loggerCallback }); return router . route ( event ); };","title":"Configurations"},{"location":"apigateway/router/configurations/#router-configurations","text":"As mentioned previously, the router is highly configurable to each project needs and desires. The point of the router is to enforce predictable thus making the API more extensible. Below is a table of all the configuration options available: Example Don't like reading documentation? Then look at our examples which can run locally!","title":"Router Configurations"},{"location":"apigateway/router/configurations/#configuration-options","text":"option type required description afterAll func no will call this function after EVERY request to the API autoValidate bool no; requires schemaPath will automatically validate request against openapi.yml basePath str yes the base path of the API Gateway instance this is running on beforeAll func no will call this function before EVERY request to the API globalLogger bool no will assign the Acai logger to the global variable globalLogger handlerPath str yes, if routingMode == 'directory' file path pointing to the directory where the endpoints are handlerPattern str yes, if routingMode == 'pattern' glob pattern to be able to find the endpoint files handlerList object yes, if routingMode == 'list' object key, value pair to be able to map routes to files loggerCallback func no will call this function on every call to global.logger onError func no will call this function on every unhandled error; not including validation errors routingMode enum yes; directory or pattern or list determines how to route requests to the right files; 3 modes schemaPath str yes, if autoValidate file path pointing to the location of the openapi.yml file withAuth func no will call this function when requirements have requiredAuth set to true","title":"Configuration Options"},{"location":"apigateway/router/configurations/#example-router-config-with-directory-routing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; const MiddlewareUtils = require ( 'api/logic/utils/middleware' ); const Authenticator = require ( 'api/logic/authenticator' ); exports . route = async ( event ) => { const router = new Router ({ basePath : 'api' , routingMode : 'directory' , handlerPath : 'api/handler' , schemaPath : 'api/openapi.yml' , autoValidate : true , globalLogger : true , beforeAll : MiddlewareUtils . beforeAll , afterAll : MiddlewareUtils . afterAll , onError : MiddlewareUtils . onError , withAuth : Authenticator . authenticate , loggerCallback : MiddlewareUtils . loggerCallback , }); return router . route ( event ); };","title":"Example: Router Config with Directory Routing"},{"location":"apigateway/router/configurations/#example-router-config-with-pattern-routing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; const MiddlewareUtils = require ( 'api/logic/utils/middleware' ); const Authenticator = require ( 'api/logic/authenticator' ); exports . route = async ( event ) => { const router = new Router ({ basePath : 'api' , routingMode : 'pattern' , handlerPattern : 'api/**/*.controller.js' , schemaPath : 'api/openapi.yml' , autoValidate : true , globalLogger : true , beforeAll : MiddlewareUtils . beforeAll , afterAll : MiddlewareUtils . afterAll , onError : MiddlewareUtils . onError , withAuth : Authenticator . authenticate , loggerCallback : MiddlewareUtils . loggerCallback , }); return router . route ( event ); };","title":"Example: Router Config with Pattern Routing"},{"location":"apigateway/router/configurations/#example-router-config-with-list-routing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; const MiddlewareUtils = require ( 'api/logic/utils/middleware' ); const Authenticator = require ( 'api/logic/authenticator' ); const routes = { 'GET::grower' : 'api/routes/grower.js' , 'POST::farm' : 'api/routes/farm.js' , 'PUT:farm/{farmId}/field/{fieldId}' : 'api/routes/farm-field.js' } exports . route = async ( event ) => { const router = new Router ({ basePath : 'api' , routingMode : 'list' , handlerList : routes , schemaPath : 'api/openapi.yml' , autoValidate : true , globalLogger : true , beforeAll : MiddlewareUtils . beforeAll , afterAll : MiddlewareUtils . afterAll , onError : MiddlewareUtils . onError , withAuth : Authenticator . authenticate , loggerCallback : MiddlewareUtils . loggerCallback }); return router . route ( event ); };","title":"Example: Router Config with List Routing"},{"location":"apigateway/router/setup/","text":"Router Set Up \u00b6 Example Don't like reading documentation? Then look at our examples which can run locally! 1. Configure the Lambda \u00b6 Serverless Framework 1 2 3 4 5 6 7 8 9 10 functions : apigateway-handler : handler : api/handler/router.route events : - http : path : / method : ANY - http : path : /{proxy+} method : ANY 2. Configure the Router \u00b6 There are three routing modes: directory , pattern and list ; directory and pattern routing mode requires your project files to be placed in a particular way; list does not require any structure, as you define every route and it's corresponding file. Below are the three ways configure your router: Routing Mode: Directory \u00b6 Tip If you are using route params, you will need use dynamic file names which follow this pattern: {some-variable-name}.js . file structure router.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ~~ Directory ~~ ~~ Route ~~ =================================================================== \ud83d\udce6api/ | \u2502---\ud83d\udcc2handler | \u2502---\ud83d\udcdcrouter.js | \u2502---\ud83d\udcdcorg.js | /org \u2502---\ud83d\udcc2grower | \u2502---\ud83d\udcdcindex.js | /grower \u2502---\ud83d\udcdc{growerId}.js | /grower/{growerId} \u2502---\ud83d\udcc2farm | \u2502---\ud83d\udcdcindex.js | /farm \u2502---\ud83d\udcc2{farmId} | \u2502---\ud83d\udcdcindex.js | /farm/{farmId} \u2502---\ud83d\udcc2field | \u2502---\ud83d\udcdcindex.js | /farm/{farmId}/field \u2502---\ud83d\udcdc{fieldId}.js | /farm/{farmId}/field/{fieldId} 1 2 3 4 5 6 7 8 9 10 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; exports . route = async ( event ) => { const router = new Router ({ routingMode : 'directory' , basePath : 'api' , // for use with custom apigateway domain handlerPath : 'api/handler' }); return router . route ( event ); }; Routing Mode: Pattern \u00b6 Tip You can use any glob pattern you like; common patterns are: /**/*.controller.js /**/handler.*.js /**/endpoint.js file structure router.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ~~ Pattern ~~ ~~ Route ~~ ================================================================================ \ud83d\udce6api/ | \u2502---\ud83d\udcdcrouter.js | \u2502---\ud83d\udcc2org | \u2502---\ud83d\udcdcorg.controller.js | /org \u2502---\ud83d\udcdcorg.model.js | \u2502---\ud83d\udcdcorg.factory.js | \u2502---\ud83d\udcdcorg.logic.js | \u2502---\ud83d\udcc2grower | \u2502---\ud83d\udcdcgrower.controller.js | /grower \u2502---\ud83d\udcdc{growerId}.controller.js | /grower/{growerId} \u2502---\ud83d\udcdcgrower.model.js | \u2502---\ud83d\udcdcgrower.factory.js | \u2502---\ud83d\udcdcgrower.logic.js | \u2502---\ud83d\udcc2farm | \u2502---\ud83d\udcdcfarm.controller.js | /farm \u2502---\ud83d\udcdcfarm.logic.js | \u2502---\ud83d\udcdcfarm.model.js | \u2502---\ud83d\udcc2{farmId} | \u2502---\ud83d\udcdc{farmId}.controller.js | /farm/{farmId} \u2502---\ud83d\udcc2field | \u2502---\ud83d\udcdcfield.controller.js | /farm/{farmId}/field \u2502---\ud83d\udcdc{fieldId}.controller.js | /farm/{farmId}/field/{fieldId} \u2502---\ud83d\udcdcfield.logic.js | \u2502---\ud83d\udcdcfield.model.js | 1 2 3 4 5 6 7 8 9 10 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; exports . route = async ( event ) => { const router = new Router ({ routingMode : 'pattern' , basePath : 'api' , // for use with custom apigateway domain handlerPattern : 'api/**/*.controller.js' }); return router . route ( event ); }; Routing Mode: List \u00b6 Tip It may be more maintainable to store your routes list in a separate file, this example does not have that for brevity Warning Even though you are matching your files to your routes, the handler files must have functions that match HTTP method (see endpoint examples here) Danger This is not the preferred routing mode to use; this can lead to a sloppy, unpredictable project architecture which will be hard to maintain and extend. This is NOT RECOMMENDED . file structure router.js 1 2 3 4 File structure doesn't matter ====================================================== \ud83d\udce6api/ \u2502---\ud83d\udcdcrouter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; exports . route = async ( event ) => { const router = new Router ({ routingMode : 'list' , basePath : 'api' , // for use with custom apigateway domain handlerList : { 'GET::grower' : 'api/routes/grower.js' , 'POST::farm' : 'api/routes/farm.js' , 'PUT:farm/{farmId}/field/{fieldId}' : 'api/routes/farm-field.js' } }); return router . route ( event ); }; 3. Configure the Endpoint File \u00b6 Every endpoint file should contain a function which matches an HTTP method in lower case. Most common are post , get , put , patch , delete , but this library does support custom methods, if you so choose. As long as the method of the request matches the function name, it will work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 exports . post = async ( request , response ) => { response . body = { post : true }; return response ; }; exports . get = async ( request , response ) => { response . body = { get : true }; return response ; }; exports . patch = async ( request , response ) => { response . body = { patch : true }; return response ; }; exports . put = async ( request , response ) => { response . body = { put : true }; return response ; }; exports . delete = async ( request , response ) => { response . body = { delete : true }; return response ; }; // this is a non-compliant, custom http method; this will work. exports . query = async ( request , response ) => { response . body = [{ query : true }]; return response ; };","title":"Set Up"},{"location":"apigateway/router/setup/#router-set-up","text":"Example Don't like reading documentation? Then look at our examples which can run locally!","title":"Router Set Up"},{"location":"apigateway/router/setup/#1-configure-the-lambda","text":"Serverless Framework 1 2 3 4 5 6 7 8 9 10 functions : apigateway-handler : handler : api/handler/router.route events : - http : path : / method : ANY - http : path : /{proxy+} method : ANY","title":"1. Configure the Lambda"},{"location":"apigateway/router/setup/#2-configure-the-router","text":"There are three routing modes: directory , pattern and list ; directory and pattern routing mode requires your project files to be placed in a particular way; list does not require any structure, as you define every route and it's corresponding file. Below are the three ways configure your router:","title":"2. Configure the Router"},{"location":"apigateway/router/setup/#routing-mode-directory","text":"Tip If you are using route params, you will need use dynamic file names which follow this pattern: {some-variable-name}.js . file structure router.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ~~ Directory ~~ ~~ Route ~~ =================================================================== \ud83d\udce6api/ | \u2502---\ud83d\udcc2handler | \u2502---\ud83d\udcdcrouter.js | \u2502---\ud83d\udcdcorg.js | /org \u2502---\ud83d\udcc2grower | \u2502---\ud83d\udcdcindex.js | /grower \u2502---\ud83d\udcdc{growerId}.js | /grower/{growerId} \u2502---\ud83d\udcc2farm | \u2502---\ud83d\udcdcindex.js | /farm \u2502---\ud83d\udcc2{farmId} | \u2502---\ud83d\udcdcindex.js | /farm/{farmId} \u2502---\ud83d\udcc2field | \u2502---\ud83d\udcdcindex.js | /farm/{farmId}/field \u2502---\ud83d\udcdc{fieldId}.js | /farm/{farmId}/field/{fieldId} 1 2 3 4 5 6 7 8 9 10 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; exports . route = async ( event ) => { const router = new Router ({ routingMode : 'directory' , basePath : 'api' , // for use with custom apigateway domain handlerPath : 'api/handler' }); return router . route ( event ); };","title":"Routing Mode: Directory"},{"location":"apigateway/router/setup/#routing-mode-pattern","text":"Tip You can use any glob pattern you like; common patterns are: /**/*.controller.js /**/handler.*.js /**/endpoint.js file structure router.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ~~ Pattern ~~ ~~ Route ~~ ================================================================================ \ud83d\udce6api/ | \u2502---\ud83d\udcdcrouter.js | \u2502---\ud83d\udcc2org | \u2502---\ud83d\udcdcorg.controller.js | /org \u2502---\ud83d\udcdcorg.model.js | \u2502---\ud83d\udcdcorg.factory.js | \u2502---\ud83d\udcdcorg.logic.js | \u2502---\ud83d\udcc2grower | \u2502---\ud83d\udcdcgrower.controller.js | /grower \u2502---\ud83d\udcdc{growerId}.controller.js | /grower/{growerId} \u2502---\ud83d\udcdcgrower.model.js | \u2502---\ud83d\udcdcgrower.factory.js | \u2502---\ud83d\udcdcgrower.logic.js | \u2502---\ud83d\udcc2farm | \u2502---\ud83d\udcdcfarm.controller.js | /farm \u2502---\ud83d\udcdcfarm.logic.js | \u2502---\ud83d\udcdcfarm.model.js | \u2502---\ud83d\udcc2{farmId} | \u2502---\ud83d\udcdc{farmId}.controller.js | /farm/{farmId} \u2502---\ud83d\udcc2field | \u2502---\ud83d\udcdcfield.controller.js | /farm/{farmId}/field \u2502---\ud83d\udcdc{fieldId}.controller.js | /farm/{farmId}/field/{fieldId} \u2502---\ud83d\udcdcfield.logic.js | \u2502---\ud83d\udcdcfield.model.js | 1 2 3 4 5 6 7 8 9 10 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; exports . route = async ( event ) => { const router = new Router ({ routingMode : 'pattern' , basePath : 'api' , // for use with custom apigateway domain handlerPattern : 'api/**/*.controller.js' }); return router . route ( event ); };","title":"Routing Mode: Pattern"},{"location":"apigateway/router/setup/#routing-mode-list","text":"Tip It may be more maintainable to store your routes list in a separate file, this example does not have that for brevity Warning Even though you are matching your files to your routes, the handler files must have functions that match HTTP method (see endpoint examples here) Danger This is not the preferred routing mode to use; this can lead to a sloppy, unpredictable project architecture which will be hard to maintain and extend. This is NOT RECOMMENDED . file structure router.js 1 2 3 4 File structure doesn't matter ====================================================== \ud83d\udce6api/ \u2502---\ud83d\udcdcrouter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { Router } = require ( '@syngenta-digital/Acai' ). apigateway ; exports . route = async ( event ) => { const router = new Router ({ routingMode : 'list' , basePath : 'api' , // for use with custom apigateway domain handlerList : { 'GET::grower' : 'api/routes/grower.js' , 'POST::farm' : 'api/routes/farm.js' , 'PUT:farm/{farmId}/field/{fieldId}' : 'api/routes/farm-field.js' } }); return router . route ( event ); };","title":"Routing Mode: List"},{"location":"apigateway/router/setup/#3-configure-the-endpoint-file","text":"Every endpoint file should contain a function which matches an HTTP method in lower case. Most common are post , get , put , patch , delete , but this library does support custom methods, if you so choose. As long as the method of the request matches the function name, it will work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 exports . post = async ( request , response ) => { response . body = { post : true }; return response ; }; exports . get = async ( request , response ) => { response . body = { get : true }; return response ; }; exports . patch = async ( request , response ) => { response . body = { patch : true }; return response ; }; exports . put = async ( request , response ) => { response . body = { put : true }; return response ; }; exports . delete = async ( request , response ) => { response . body = { delete : true }; return response ; }; // this is a non-compliant, custom http method; this will work. exports . query = async ( request , response ) => { response . body = [{ query : true }]; return response ; };","title":"3. Configure the Endpoint File"},{"location":"common/logger/","text":"The Acai logger is automatically logs in a formatted JSON string for easy reading and searching with AWS Cloud Watch. A developer can then use AWS filter patterns making it effortless to find the exact log they are looking for. Below is an example of how to use the logger: Examples \u00b6 Basic Usage \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // if you use globalLogger: true, in any config the logger is available globally global . logger . info ( 'testing info' ); global . logger . debug ( 'testing debug' ); global . logger . warn ( 'testing warn' ); global . logger . error ( 'testing warn' ); // standard output { level : '$LEVEL' , log : '$MESSGE' } Advance Usage \u00b6 1 2 3 4 5 6 7 8 9 10 // if you use globalLogger: true, in any config the logger is available globally global . logger . log ({ level : 'INFO' , log : { someKey : 'testing info' }}); // standard output { level : 'INFO' , log : { someKey : 'testing info' } }","title":"Logger"},{"location":"common/logger/#examples","text":"","title":"Examples"},{"location":"common/logger/#basic-usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // if you use globalLogger: true, in any config the logger is available globally global . logger . info ( 'testing info' ); global . logger . debug ( 'testing debug' ); global . logger . warn ( 'testing warn' ); global . logger . error ( 'testing warn' ); // standard output { level : '$LEVEL' , log : '$MESSGE' }","title":"Basic Usage"},{"location":"common/logger/#advance-usage","text":"1 2 3 4 5 6 7 8 9 10 // if you use globalLogger: true, in any config the logger is available globally global . logger . log ({ level : 'INFO' , log : { someKey : 'testing info' }}); // standard output { level : 'INFO' , log : { someKey : 'testing info' } }","title":"Advance Usage"},{"location":"dynamodb/","text":"Event handler for Amazon DynamoDB Stream Events. Features \u00b6 Automatically convert DynamoDB JSON to standard JSON Only run on certain DynamoDB operations, like on when items are created, updated or deleted Able to validate DynamoDB record against a JSON Schema Assign Data Classes to records instead of getting raw DynamoDB JSON objects","title":"DynamoDB"},{"location":"dynamodb/#features","text":"Automatically convert DynamoDB JSON to standard JSON Only run on certain DynamoDB operations, like on when items are created, updated or deleted Able to validate DynamoDB record against a JSON Schema Assign Data Classes to records instead of getting raw DynamoDB JSON objects","title":"Features"},{"location":"dynamodb/configurations/","text":"DynamoDB Event Configurations \u00b6 The Dynamodb event will automatically handle many common things done when eventing off a DynamoDB stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use. Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! Configuration Options \u00b6 option type required default description before func no null a custom function to be ran before your records are pulled dataClass class no null a custom class that will be passed instead of the records object globalLogger bool no false will assign the Acai logger to the global variable globalLogger operations array no ['create', 'update', 'delete'] will only run if record was created from the listed operation operationError bool no false will raise exception if operation of record is not from listed operations requiredBody str or obj no null will validate body of record against this schema schemaPath str no null file path pointing to the location of the openapi.yml file validationError bool no false will raise exception if validation of record fails Example: DynamoDB Configuration Options \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const EventClient = require ( '@syngenta-digital/Acai' ). dynamodb . Event ; const Grower = require ( 'api/logic/grower' ); exports . stream = async ( event ) => { const options = { globalLogger : true , operations : [ 'create' , 'update' ], // [create, update, delete] by default operationError : false , // will raise exception if wrong operation; default false requiredBody : 'ddb-record' , schemaPath : 'api/openapi.yml' , validationError : false , // will raise exception if validation fails; default false dataClass : Grower , // will get instance of this instead of record instance before : ( records ) => { // run this before records are sent } } const eventClient = new EventClient ( event , options ); const records = await eventClient . getRecords (); for ( const grower of records ) { // do stuff here } };","title":"Configurations"},{"location":"dynamodb/configurations/#dynamodb-event-configurations","text":"The Dynamodb event will automatically handle many common things done when eventing off a DynamoDB stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use. Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account!","title":"DynamoDB Event Configurations"},{"location":"dynamodb/configurations/#configuration-options","text":"option type required default description before func no null a custom function to be ran before your records are pulled dataClass class no null a custom class that will be passed instead of the records object globalLogger bool no false will assign the Acai logger to the global variable globalLogger operations array no ['create', 'update', 'delete'] will only run if record was created from the listed operation operationError bool no false will raise exception if operation of record is not from listed operations requiredBody str or obj no null will validate body of record against this schema schemaPath str no null file path pointing to the location of the openapi.yml file validationError bool no false will raise exception if validation of record fails","title":"Configuration Options"},{"location":"dynamodb/configurations/#example-dynamodb-configuration-options","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const EventClient = require ( '@syngenta-digital/Acai' ). dynamodb . Event ; const Grower = require ( 'api/logic/grower' ); exports . stream = async ( event ) => { const options = { globalLogger : true , operations : [ 'create' , 'update' ], // [create, update, delete] by default operationError : false , // will raise exception if wrong operation; default false requiredBody : 'ddb-record' , schemaPath : 'api/openapi.yml' , validationError : false , // will raise exception if validation fails; default false dataClass : Grower , // will get instance of this instead of record instance before : ( records ) => { // run this before records are sent } } const eventClient = new EventClient ( event , options ); const records = await eventClient . getRecords (); for ( const grower of records ) { // do stuff here } };","title":"Example: DynamoDB Configuration Options"},{"location":"dynamodb/record/","text":"DynamoDB Record Object \u00b6 The DynamoDB event will by default provide instances of record classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the dataClass , if you provide on in your configuration. Below is a list of all the properties and example outputs for the DynamoDB event record: Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! Record Properties \u00b6 property type description body object the new image of dynamodb record; created or updated created float the approximate creationDate time expired bool whether the ttl has expired id str the id of the event which invoked the lambda identity object the identity who triggered the dynamodb change keys object the keys of DynamoDB record name str the name of the event which invoked the lambda newImage object the new image of dynamodb record; created or updated oldImage object the old image of dynamodb record; updated or deleted operation str triggered operation lambda (create, update, delete) region str the region the record is from size int the size in bytes of the record source str the source of the event which invoked the lambda sourceARN str the event source arn streamType str the stream view type version str the event version record.region \u00b6 1 2 3 4 console . log ( record . region ); // example output: 'us-east-2' record.id \u00b6 1 2 3 4 console . log ( record . id ); // example output: '9a37c0d03eb60f7cf70cabc823de9907' record.name \u00b6 1 2 3 4 console . log ( record . name ); // example output: 'INSERT' record.source \u00b6 1 2 3 4 console . log ( record . source ); // example output: 'aws:dynamodb' record.keys \u00b6 Info This is converted from the original DDB JSON to standard json 1 2 3 4 5 6 console . log ( record . keys ); // example output: { example_id : '123456789' } record.oldImage \u00b6 Info This is converted from the original DDB JSON to standard json 1 2 3 4 5 6 console . log ( record . oldImage ); // example output: { old_data : '123456789' } record.newImage \u00b6 Info This is converted from the original DDB JSON to standard json 1 2 3 4 5 6 console . log ( record . newImage ); // example output: { new_data : '123456789' } record.body \u00b6 Info This is converted from the original DDB JSON to standard json from newImage 1 2 3 4 5 6 console . log ( record . body ); // example output: { new_data : '123456789' } record.operation \u00b6 1 2 3 4 console . log ( record . operation ); // example output: 'create' record.sourceARN \u00b6 1 2 3 4 console . log ( record . sourceARN ); // example output: 'arn:aws:dynamodb:us-east-1:771875143460:table/test-example/stream/2019-10-04T23:18:26.340' record.version \u00b6 1 2 3 4 console . log ( record . version ); // example output: '1.1' record.streamType \u00b6 1 2 3 4 console . log ( record . streamType ); // example output: 'NEW_AND_OLD_IMAGES' record.size \u00b6 1 2 3 4 console . log ( record . size ); // example output: 1124 record.created \u00b6 1 2 3 4 console . log ( record . created ); // example output: 1538695200.0 //unix timestamp record.identity \u00b6 1 2 3 4 5 6 7 console . log ( record . identity ); // example output: { type : 'Service' , principalId : 'dynamodb.amazonaws.com' } record.expired \u00b6 1 2 3 4 console . log ( record . expired ); // example output: false","title":"Record"},{"location":"dynamodb/record/#dynamodb-record-object","text":"The DynamoDB event will by default provide instances of record classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the dataClass , if you provide on in your configuration. Below is a list of all the properties and example outputs for the DynamoDB event record: Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account!","title":"DynamoDB Record Object"},{"location":"dynamodb/record/#record-properties","text":"property type description body object the new image of dynamodb record; created or updated created float the approximate creationDate time expired bool whether the ttl has expired id str the id of the event which invoked the lambda identity object the identity who triggered the dynamodb change keys object the keys of DynamoDB record name str the name of the event which invoked the lambda newImage object the new image of dynamodb record; created or updated oldImage object the old image of dynamodb record; updated or deleted operation str triggered operation lambda (create, update, delete) region str the region the record is from size int the size in bytes of the record source str the source of the event which invoked the lambda sourceARN str the event source arn streamType str the stream view type version str the event version","title":"Record Properties"},{"location":"dynamodb/record/#recordregion","text":"1 2 3 4 console . log ( record . region ); // example output: 'us-east-2'","title":"record.region"},{"location":"dynamodb/record/#recordid","text":"1 2 3 4 console . log ( record . id ); // example output: '9a37c0d03eb60f7cf70cabc823de9907'","title":"record.id"},{"location":"dynamodb/record/#recordname","text":"1 2 3 4 console . log ( record . name ); // example output: 'INSERT'","title":"record.name"},{"location":"dynamodb/record/#recordsource","text":"1 2 3 4 console . log ( record . source ); // example output: 'aws:dynamodb'","title":"record.source"},{"location":"dynamodb/record/#recordkeys","text":"Info This is converted from the original DDB JSON to standard json 1 2 3 4 5 6 console . log ( record . keys ); // example output: { example_id : '123456789' }","title":"record.keys"},{"location":"dynamodb/record/#recordoldimage","text":"Info This is converted from the original DDB JSON to standard json 1 2 3 4 5 6 console . log ( record . oldImage ); // example output: { old_data : '123456789' }","title":"record.oldImage"},{"location":"dynamodb/record/#recordnewimage","text":"Info This is converted from the original DDB JSON to standard json 1 2 3 4 5 6 console . log ( record . newImage ); // example output: { new_data : '123456789' }","title":"record.newImage"},{"location":"dynamodb/record/#recordbody","text":"Info This is converted from the original DDB JSON to standard json from newImage 1 2 3 4 5 6 console . log ( record . body ); // example output: { new_data : '123456789' }","title":"record.body"},{"location":"dynamodb/record/#recordoperation","text":"1 2 3 4 console . log ( record . operation ); // example output: 'create'","title":"record.operation"},{"location":"dynamodb/record/#recordsourcearn","text":"1 2 3 4 console . log ( record . sourceARN ); // example output: 'arn:aws:dynamodb:us-east-1:771875143460:table/test-example/stream/2019-10-04T23:18:26.340'","title":"record.sourceARN"},{"location":"dynamodb/record/#recordversion","text":"1 2 3 4 console . log ( record . version ); // example output: '1.1'","title":"record.version"},{"location":"dynamodb/record/#recordstreamtype","text":"1 2 3 4 console . log ( record . streamType ); // example output: 'NEW_AND_OLD_IMAGES'","title":"record.streamType"},{"location":"dynamodb/record/#recordsize","text":"1 2 3 4 console . log ( record . size ); // example output: 1124","title":"record.size"},{"location":"dynamodb/record/#recordcreated","text":"1 2 3 4 console . log ( record . created ); // example output: 1538695200.0 //unix timestamp","title":"record.created"},{"location":"dynamodb/record/#recordidentity","text":"1 2 3 4 5 6 7 console . log ( record . identity ); // example output: { type : 'Service' , principalId : 'dynamodb.amazonaws.com' }","title":"record.identity"},{"location":"dynamodb/record/#recordexpired","text":"1 2 3 4 console . log ( record . expired ); // example output: false","title":"record.expired"},{"location":"s3/","text":"Event handler for Amazon S3 Bucket Events. Features \u00b6 Automatically convert JSON files to JSON objects Automatically convert CSV files to JSON objects Only run on certain S3 operations, like on when items are created, updated or deleted Able to validate S3 record against a JSON Schema Assign Data Classes to records instead of getting raw S3 JSON objects","title":"S3"},{"location":"s3/#features","text":"Automatically convert JSON files to JSON objects Automatically convert CSV files to JSON objects Only run on certain S3 operations, like on when items are created, updated or deleted Able to validate S3 record against a JSON Schema Assign Data Classes to records instead of getting raw S3 JSON objects","title":"Features"},{"location":"s3/configurations/","text":"S3 Event Configurations \u00b6 The S3 event will automatically handle many common things done when eventing off a S3 event. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use. Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! Configuration Options \u00b6 option type required default description before func no null a custom function to be ran before your records are pulled dataClass class no null a custom class that will be passed instead of the records object getObject bool no false will pull the file from S3 bucket and hold in memory globalLogger bool no false will assign the Acai logger to the global variable globalLogger isJSON bool no false will convert file into JSON object; requires getObject isCSV bool no false will convert file into CSV object; requires getObject operations array no ['create', 'update', 'delete'] will only run if record was created from the listed operation operationError bool no false will raise exception if operation of record is not from listed operations requiredBody str or obj no null will validate body of record against this schema, requires isJSON schemaPath str no null file path pointing to the location of the openapi.yml file validationError bool no false will raise exception if validation of record fails Example: S3 Configuration Options \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const EventClient = require ( 'acai-js' ). s3 . Event ; const Grower = require ( 'api/logic/grower' ); exports . eventer = async ( event ) => { const options = { globalLogger : true , operations : [ 'create' , 'delete' ], // [create, update, delete] by default; s3 doesn't support delete operationError : false , // will raise exception if wrong operation; default false requiredBody : 's3-record' , // only works with isJSON schemaPath : 'api/openapi.yml' , // only works with isJSON validationError : false , // will raise exception if validation fails; default false getObject : true , // required for isJSON or isCSV isJSON : true , // will convert file into JSON object, must be valid JSON file isCSV : false , // will convert file into object, must be valid CSV file dataClass : Grower , // will get instance of this instead of record instance before : ( records ) => { // run this before records are sent } } const eventClient = new EventClient ( event , options ); const records = await eventClient . getRecords (); for ( const grower of records ) { // do stuff here } };","title":"Configurations"},{"location":"s3/configurations/#s3-event-configurations","text":"The S3 event will automatically handle many common things done when eventing off a S3 event. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use. Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account!","title":"S3 Event Configurations"},{"location":"s3/configurations/#configuration-options","text":"option type required default description before func no null a custom function to be ran before your records are pulled dataClass class no null a custom class that will be passed instead of the records object getObject bool no false will pull the file from S3 bucket and hold in memory globalLogger bool no false will assign the Acai logger to the global variable globalLogger isJSON bool no false will convert file into JSON object; requires getObject isCSV bool no false will convert file into CSV object; requires getObject operations array no ['create', 'update', 'delete'] will only run if record was created from the listed operation operationError bool no false will raise exception if operation of record is not from listed operations requiredBody str or obj no null will validate body of record against this schema, requires isJSON schemaPath str no null file path pointing to the location of the openapi.yml file validationError bool no false will raise exception if validation of record fails","title":"Configuration Options"},{"location":"s3/configurations/#example-s3-configuration-options","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const EventClient = require ( 'acai-js' ). s3 . Event ; const Grower = require ( 'api/logic/grower' ); exports . eventer = async ( event ) => { const options = { globalLogger : true , operations : [ 'create' , 'delete' ], // [create, update, delete] by default; s3 doesn't support delete operationError : false , // will raise exception if wrong operation; default false requiredBody : 's3-record' , // only works with isJSON schemaPath : 'api/openapi.yml' , // only works with isJSON validationError : false , // will raise exception if validation fails; default false getObject : true , // required for isJSON or isCSV isJSON : true , // will convert file into JSON object, must be valid JSON file isCSV : false , // will convert file into object, must be valid CSV file dataClass : Grower , // will get instance of this instead of record instance before : ( records ) => { // run this before records are sent } } const eventClient = new EventClient ( event , options ); const records = await eventClient . getRecords (); for ( const grower of records ) { // do stuff here } };","title":"Example: S3 Configuration Options"},{"location":"s3/record/","text":"S3 Record Object \u00b6 The S3 event will by default provide instances of record classes which will be easier to work with then standard lambda event record object. This is the same object which will be passed down to the dataClass , if you provide on in your configuration. Below is a list of all the properties and example outputs for the S3 event record: Example Don't like reading documentation? Then look at our examples which can be deployed in 1 command into your AWS account! Record Properties \u00b6 property type description body object the object from the bucket in memory; buffer, json or csv object bucket str the name of the bucket id str the id of configuration key str the bucket key name str the name of the event which invoked the lambda object object the object described from the bucket operation str triggered operation lambda (create, delete) region str the region the record is from request object the request parameters response object the response parameters source str the source of the event which invoked the lambda time float the event time version object the s3 schema version record.region \u00b6 1 2 3 4 console . log ( record . region ); // example output: 'us-east-2' record.body \u00b6 1 2 3 4 console . log ( record . body ); // example output: depending on the configuration, it might be a Buffer, CSV, or JSON object // does require `getObject: true` to be set in the options of the EventClient record.bucket \u00b6 1 2 3 4 5 6 7 8 9 10 console . log ( record . bucket ); // example output: { \"name\" : \"DOC-EXAMPLE-BUCKET\" , \"ownerIdentity\" : { \"principalId\" : \"A3I5XTEXAMAI3E\" }, \"arn\" : \"arn:aws:s3:::lambda-artifacts-deafc19498e3f2df\" } record.id \u00b6 1 2 3 4 console . log ( record . id ); // example output: '828aa6fc-f7b5-4305-8584-487c791949c1' record.name \u00b6 1 2 3 4 console . log ( record . name ); // example output: 'ObjectCreated:Put' record.source \u00b6 1 2 3 4 console . log ( record . source ); // example output: 'aws:s3' record.time \u00b6 1 2 3 4 console . log ( record . time ); // example output: '2019-09-03T19:37:27.192Z' record.key \u00b6 1 2 3 4 console . log ( record . key ); // example output: 'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json' record.object \u00b6 1 2 3 4 5 6 7 8 9 console . log ( record . object ); // example output: { 'key' : 'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json' , 'size' : 1305107 , 'eTag' : 'b21b84d653bb07b05b1e6b33684dc11b' , 'sequencer' : '0C0F6F405D6ED209E1' } record.operation \u00b6 1 2 3 4 console . log ( record . operation ); // example output: 'create' record.request \u00b6 1 2 3 4 5 6 console . log ( record . request ); // example output: { \"sourceIPAddress\" : \"205.255.255.255\" } record.response \u00b6 1 2 3 4 5 6 7 console . log ( record . response ); // example output: { \"x-amz-request-id\" : \"D82B88E5F771F645\" , \"x-amz-id-2\" : \"vlR7PnpV2Ce81l0PRw6jlUpck7Jo5ZsQjryTjKlc5aLWGVHPZLj5NeC6qMa0emYBDXOo6QBU0Wo=\" } record.version \u00b6 1 2 3 4 console . log ( record . version ); // example output: \"1.0\"","title":"Record"},{"location":"s3/record/#s3-record-object","text":"The S3 event will by default provide instances of record classes which will be easier to work with then standard lambda event record object. This is the same object which will be passed down to the dataClass , if you provide on in your configuration. Below is a list of all the properties and example outputs for the S3 event record: Example Don't like reading documentation? Then look at our examples which can be deployed in 1 command into your AWS account!","title":"S3 Record Object"},{"location":"s3/record/#record-properties","text":"property type description body object the object from the bucket in memory; buffer, json or csv object bucket str the name of the bucket id str the id of configuration key str the bucket key name str the name of the event which invoked the lambda object object the object described from the bucket operation str triggered operation lambda (create, delete) region str the region the record is from request object the request parameters response object the response parameters source str the source of the event which invoked the lambda time float the event time version object the s3 schema version","title":"Record Properties"},{"location":"s3/record/#recordregion","text":"1 2 3 4 console . log ( record . region ); // example output: 'us-east-2'","title":"record.region"},{"location":"s3/record/#recordbody","text":"1 2 3 4 console . log ( record . body ); // example output: depending on the configuration, it might be a Buffer, CSV, or JSON object // does require `getObject: true` to be set in the options of the EventClient","title":"record.body"},{"location":"s3/record/#recordbucket","text":"1 2 3 4 5 6 7 8 9 10 console . log ( record . bucket ); // example output: { \"name\" : \"DOC-EXAMPLE-BUCKET\" , \"ownerIdentity\" : { \"principalId\" : \"A3I5XTEXAMAI3E\" }, \"arn\" : \"arn:aws:s3:::lambda-artifacts-deafc19498e3f2df\" }","title":"record.bucket"},{"location":"s3/record/#recordid","text":"1 2 3 4 console . log ( record . id ); // example output: '828aa6fc-f7b5-4305-8584-487c791949c1'","title":"record.id"},{"location":"s3/record/#recordname","text":"1 2 3 4 console . log ( record . name ); // example output: 'ObjectCreated:Put'","title":"record.name"},{"location":"s3/record/#recordsource","text":"1 2 3 4 console . log ( record . source ); // example output: 'aws:s3'","title":"record.source"},{"location":"s3/record/#recordtime","text":"1 2 3 4 console . log ( record . time ); // example output: '2019-09-03T19:37:27.192Z'","title":"record.time"},{"location":"s3/record/#recordkey","text":"1 2 3 4 console . log ( record . key ); // example output: 'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json'","title":"record.key"},{"location":"s3/record/#recordobject","text":"1 2 3 4 5 6 7 8 9 console . log ( record . object ); // example output: { 'key' : 'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json' , 'size' : 1305107 , 'eTag' : 'b21b84d653bb07b05b1e6b33684dc11b' , 'sequencer' : '0C0F6F405D6ED209E1' }","title":"record.object"},{"location":"s3/record/#recordoperation","text":"1 2 3 4 console . log ( record . operation ); // example output: 'create'","title":"record.operation"},{"location":"s3/record/#recordrequest","text":"1 2 3 4 5 6 console . log ( record . request ); // example output: { \"sourceIPAddress\" : \"205.255.255.255\" }","title":"record.request"},{"location":"s3/record/#recordresponse","text":"1 2 3 4 5 6 7 console . log ( record . response ); // example output: { \"x-amz-request-id\" : \"D82B88E5F771F645\" , \"x-amz-id-2\" : \"vlR7PnpV2Ce81l0PRw6jlUpck7Jo5ZsQjryTjKlc5aLWGVHPZLj5NeC6qMa0emYBDXOo6QBU0Wo=\" }","title":"record.response"},{"location":"s3/record/#recordversion","text":"1 2 3 4 console . log ( record . version ); // example output: \"1.0\"","title":"record.version"},{"location":"sqs/","text":"Event handler for Amazon SNS/SQS Events. Features \u00b6 Automatically convert JSON from message body Automatically flatten message attributes Able to message body against a JSON Schema Assign Data Classes to records instead of getting record objects","title":"SNS/SQS"},{"location":"sqs/#features","text":"Automatically convert JSON from message body Automatically flatten message attributes Able to message body against a JSON Schema Assign Data Classes to records instead of getting record objects","title":"Features"},{"location":"sqs/configurations/","text":"SNS/SQS Event Configurations \u00b6 The SNS/SQS event will automatically handle many common things done when eventing off an SNS/SQS stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use. Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! Configuration Options \u00b6 option type required default description before func no null a custom function to be ran before your records are pulled dataClass class no null a custom class that will be passed instead of the records object globalLogger bool no false will assign the Acai logger to the global variable globalLogger requiredBody str or obj no null will validate body of record against this schema schemaPath str no null file path pointing to the location of the openapi.yml file validationError bool no false will raise exception if validation of record fails Example: SNS/SQS Configuration Options \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const EventClient = require ( '@syngenta-digital/Acai' ). sqs . Event ; const Grower = require ( 'api/logic/grower' ); exports . listen = async ( event ) => { const options = { globalLogger : true , requiredBody : 'sqs-record' , schemaPath : 'api/openapi.yml' , validationError : false , // will raise exception if validation fails; default false dataClass : Grower , // will get instance of this instead of record instance before : ( records ) => { // run this before records are sent } } const eventClient = new EventClient ( event , options ); const records = await eventClient . getRecords (); for ( const grower of records ) { // do stuff here } };","title":"Configurations"},{"location":"sqs/configurations/#snssqs-event-configurations","text":"The SNS/SQS event will automatically handle many common things done when eventing off an SNS/SQS stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use. Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account!","title":"SNS/SQS Event Configurations"},{"location":"sqs/configurations/#configuration-options","text":"option type required default description before func no null a custom function to be ran before your records are pulled dataClass class no null a custom class that will be passed instead of the records object globalLogger bool no false will assign the Acai logger to the global variable globalLogger requiredBody str or obj no null will validate body of record against this schema schemaPath str no null file path pointing to the location of the openapi.yml file validationError bool no false will raise exception if validation of record fails","title":"Configuration Options"},{"location":"sqs/configurations/#example-snssqs-configuration-options","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const EventClient = require ( '@syngenta-digital/Acai' ). sqs . Event ; const Grower = require ( 'api/logic/grower' ); exports . listen = async ( event ) => { const options = { globalLogger : true , requiredBody : 'sqs-record' , schemaPath : 'api/openapi.yml' , validationError : false , // will raise exception if validation fails; default false dataClass : Grower , // will get instance of this instead of record instance before : ( records ) => { // run this before records are sent } } const eventClient = new EventClient ( event , options ); const records = await eventClient . getRecords (); for ( const grower of records ) { // do stuff here } };","title":"Example: SNS/SQS Configuration Options"},{"location":"sqs/record/","text":"SNS/SQS Record Object \u00b6 The SNS/SQS event will by default provide instances of record classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the dataClass , if you provide on in your configuration. Below is a list of all the properties and example outputs for the SNS/SQS event record: Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! Record Properties \u00b6 property type description attributes object the attributes of the message body object the object from the bucket in memory; decodes json automatically id str the id of message md5 str the message in an md4 hash format messageAttributes object the attributes of the message, flattened raw any the body of the message as is, no conversion receiptHandle str the handle of the receipt region str the region of the message source str the source of the event which invoked the lambda sourceARN str the arn of the source record.attributes \u00b6 1 2 3 4 5 6 7 8 9 console . log ( record . attributes ); // example output: { \"ApproximateReceiveCount\" : \"1\" , \"SentTimestamp\" : \"1545082650636\" , \"SenderId\" : \"AIDAIENQZJOLO23YVJ4VO\" , \"ApproximateFirstReceiveTimestamp\" : \"1545082650649\" } record.body \u00b6 1 2 3 4 5 6 console . log ( record . body ); // example output: { some_key : 'some_value' } record.source \u00b6 1 2 3 4 console . log ( record . source ); // example output: 'aws:sqs' record.md5 \u00b6 1 2 3 4 console . log ( record . md5 ); // example output: 'e4e68fb7bd0e697a0ae8f1bb342846b3' record.messageAttributes \u00b6 1 2 3 4 5 6 console . log ( record . messageAttributes ); // example output: { some_attribute_key : 'some_attribute_value' } record.id \u00b6 1 2 3 4 console . log ( record . id ); // example output: '2e1424d4-f796-459a-8184-9c92662be6da' record.raw \u00b6 1 2 3 4 console . log ( record . raw ); // example output: '{\"some_key\": \"some_value\"}' record.receiptHandle \u00b6 1 2 3 4 console . log ( record . receiptHandle ); // example output: 'AQEBzWwaftRI0KuVm4tP+/7q1rGgNqicHq...' record.region \u00b6 1 2 3 4 console . log ( record . region ); // example output: 'us-east-2' record.sourceARN \u00b6 1 2 3 4 console . log ( record . sourceARN ); // example output: 'arn:aws:sqs:us-east-2:123456789012:my-queue'","title":"Record"},{"location":"sqs/record/#snssqs-record-object","text":"The SNS/SQS event will by default provide instances of record classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the dataClass , if you provide on in your configuration. Below is a list of all the properties and example outputs for the SNS/SQS event record: Examples Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account!","title":"SNS/SQS Record Object"},{"location":"sqs/record/#record-properties","text":"property type description attributes object the attributes of the message body object the object from the bucket in memory; decodes json automatically id str the id of message md5 str the message in an md4 hash format messageAttributes object the attributes of the message, flattened raw any the body of the message as is, no conversion receiptHandle str the handle of the receipt region str the region of the message source str the source of the event which invoked the lambda sourceARN str the arn of the source","title":"Record Properties"},{"location":"sqs/record/#recordattributes","text":"1 2 3 4 5 6 7 8 9 console . log ( record . attributes ); // example output: { \"ApproximateReceiveCount\" : \"1\" , \"SentTimestamp\" : \"1545082650636\" , \"SenderId\" : \"AIDAIENQZJOLO23YVJ4VO\" , \"ApproximateFirstReceiveTimestamp\" : \"1545082650649\" }","title":"record.attributes"},{"location":"sqs/record/#recordbody","text":"1 2 3 4 5 6 console . log ( record . body ); // example output: { some_key : 'some_value' }","title":"record.body"},{"location":"sqs/record/#recordsource","text":"1 2 3 4 console . log ( record . source ); // example output: 'aws:sqs'","title":"record.source"},{"location":"sqs/record/#recordmd5","text":"1 2 3 4 console . log ( record . md5 ); // example output: 'e4e68fb7bd0e697a0ae8f1bb342846b3'","title":"record.md5"},{"location":"sqs/record/#recordmessageattributes","text":"1 2 3 4 5 6 console . log ( record . messageAttributes ); // example output: { some_attribute_key : 'some_attribute_value' }","title":"record.messageAttributes"},{"location":"sqs/record/#recordid","text":"1 2 3 4 console . log ( record . id ); // example output: '2e1424d4-f796-459a-8184-9c92662be6da'","title":"record.id"},{"location":"sqs/record/#recordraw","text":"1 2 3 4 console . log ( record . raw ); // example output: '{\"some_key\": \"some_value\"}'","title":"record.raw"},{"location":"sqs/record/#recordreceipthandle","text":"1 2 3 4 console . log ( record . receiptHandle ); // example output: 'AQEBzWwaftRI0KuVm4tP+/7q1rGgNqicHq...'","title":"record.receiptHandle"},{"location":"sqs/record/#recordregion","text":"1 2 3 4 console . log ( record . region ); // example output: 'us-east-2'","title":"record.region"},{"location":"sqs/record/#recordsourcearn","text":"1 2 3 4 console . log ( record . sourceARN ); // example output: 'arn:aws:sqs:us-east-2:123456789012:my-queue'","title":"record.sourceARN"}]}